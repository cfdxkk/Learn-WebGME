/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Wed Jun 05 2024 22:03:31 GMT+0800 (中国标准时间).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
	'plugin/PluginConfig',
	'text!./metadata.json',
	'plugin/PluginBase',
	'q', // The promise library
	'common/storage/constants', // These will be needed to check that the commit did update the branch
], function (
	PluginConfig,
	pluginMetadata,
	PluginBase,
	Q,
	STORAGE_CONSTANTS) {
	'use strict';

	const
		fs = require('fs'),
		path = require('path'),
		cp = require('child_process'),
		os = require('os');

	pluginMetadata = JSON.parse(pluginMetadata);

	/**
	 * Initializes a new instance of SimulateModelica.
	 * @class
	 * @augments {PluginBase}
	 * @classdesc This class represents the plugin SimulateModelica.
	 * @constructor
	 */
	function SimulateModelica() {
			// Call base class' constructor.
			PluginBase.call(this);
			this.pluginMetadata = pluginMetadata;
	}

	/**
	 * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
	 * This is also available at the instance at this.pluginMetadata.
	 * @type {object}
	 */
	SimulateModelica.metadata = pluginMetadata;

	// Prototypical inheritance from PluginBase.
	SimulateModelica.prototype = Object.create(PluginBase.prototype);
	SimulateModelica.prototype.constructor = SimulateModelica;

	/**
	 * Main function for the plugin to execute. This will perform the execution.
	 * Notes:
	 * - Always log with the provided logger.[error,warning,info,debug].
	 * - Do NOT put any user interaction logic UI, etc. inside this method.
	 * - callback always has to be called even if error happened.
	 *
	 * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
	 */
	SimulateModelica.prototype.main = function (callback) {
		// Use this to access core, project, result, logger etc from PluginBase.
		const
			self = this,
			logger = this.logger,
			activeNode = self.activeNode;

		function generateDirectory(modelName) {
			const MAX_DIR_TRIES = 100;
			let result

			try {
				fs.mkdirSync('outputs')
			} catch (error) {
				if (error.code !== 'EEXIST') {
					throw error
				}
			}

			const dirName = `${modelName}_${Date.now()}`

			for (let i = 0; i < MAX_DIR_TRIES; i++) {
				result = path.join('outputs', `${dirName}__${i}`)
				try {
					fs.mkdirSync(result)
					break
				} catch (error) {
					if (error.code !== 'EEXIST') {
						throw error
					} else if (i === MAX_DIR_TRIES - 1) {
						throw new Error(`Failed to generate unique output directory after ${MAX_DIR_TRIES} attempts!`)
					}
				}
			}

			return result
		}

		function writeFIle(dir, moFileContent, modelName, stopTime) {
			fs.writeFileSync(path.join(dir, `${modelName}.mo`), moFileContent)
			fs.writeFileSync(path.join(dir, 'simulate.mos'), [
				'loadModel(Modelica); getErrorString();',
				`loadFile("${modelName}.mo"); getErrorString();`,
				`simulate(${modelName}, startTime=0.0, stopTime=${stopTime}, outputFormat="csv"); getErrorString();`,
			].join('\n'))
		}

		function simulateModel(dir, modelName) {
			let command
			if (os.platform().indexOf('win') === 0) {
				command = '%OPENMODELICAHOME%\\bin\\omc.exe simulate.mos'
			} else {
				command = 'omc simulate.mos'
			}

			return Q.ninvoke(cp, 'exec', command, { cwd: dir }).then(res => {
				logger.info(res)
				return {
					dir: dir,
					resultFileName: `${modelName}_res.csv`
				}
			})
		}

		self.invokePlugin('ModelicaCodeGenerator')
			.then(result => {
				if (result.getSuccess() !== true) {
					throw new Error('ModelicaCodeGenerator did not return with success!')
				}

				const moFileHash = result.getArtifacts()[0]; // Array of hashes we know only one was addes

				self.result.addArtifact(moFileHash); // Return the mo-file to the user as well

				return self.blobClient.getObjectAsString(moFileHash)
			})
			.then(moFileContent => {
				logger.info('moFileContent', moFileContent)
				const modelName = self.core.getAttribute(activeNode, 'name')
				const dir = generateDirectory(modelName)
				writeFIle(dir, moFileContent, modelName, self.getCurrentConfig().stopTime)

				return simulateModel(dir, modelName)
			})
			.then(res => {
				return self.blobClient.putFile(res.resultFileName, fs.readFileSync(path.join(res.dir, res.resultFileName)))
			})
			.then(csvFileHash => {
				self.core.setAttribute(activeNode, 'simResults', csvFileHash)

				return self.save(`Attached Simulation results at ${self.core.getPath(activeNode)}`)
			})
			.then(commitResult => {
				if (commitResult.status === STORAGE_CONSTANTS.SYNCED) {
					self.result.setSuccess(true);
					callback(null, self.result);
				} else {
					self.createMessage(activeNode, 'Simulation succeeded but commit did not update branch.')
					callback(new Error('Did not update branch.'), self.result)
				}
			})
			.catch((err) => {
					// Result success is false at invocation.
					self.logger.error(err.stack);
					callback(err, self.result);
			});
	};

	return SimulateModelica;
});
